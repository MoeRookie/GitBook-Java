## 自动类型转换

```java
class Demo02 {
    public static void main(String[] args){
        byte b = 11; // 声明byte类型的b变量,并将11存储到b变量中
        short s = b; // 声明short类型的s变量,并将b变量中存储的值存储到s变量中
        int i = s; // 声明int类型的i变量,并将s变量中存储的值存储到i变量中
        long l = i; // 声明long类型的l变量,并将i变量中存储的值存储到l变量中
        System.out.println(l);
    }
}
```

* #### 如上所示\(小数据类型-&gt;大数据类型\)

```java
byte类型的b变量,占1个字节的内存空间,好比一两碗;
short类型的s变量,占2个字节的内存空间,好比二两碗,以此类推...
一两碗能盛得了的饭,二两碗能盛,以此类推...
故小数据类型到大数据类型的转换是自动完成的,不需要任何的其他操作;
```

## 强制类型转换

#### 格式 : \(大数据类型-&gt;小数据类型\)

```java
小数据类型 变量名 = (小数据类型)大数据类型[变量名];
```

* ##### 示例 :

```java
/*
    四两碗盛得饭可能比二两碗盛得饭多,即可能会溢出数据...
*/
class Demo02 {
    public static void main(String[] args){
        int i = 10; // 4个字节
        byte b = (byte)i; // 2个字节
        System.out.println(b);
    }
}
```

#### 疑问 :

* ##### 上述之所以能够强转 , 是因为 10 并没有超出 b 变量所能表示数据的范围 ; 那么假如说 i = 128 呢? b 的值是不是我们想象中溢出后的127呢?

```java
/*
    四两碗盛得饭可能比二两碗盛得饭多,即可能会溢出数据...
*/
class Demo02 {
    public static void main(String[] args){
        int i = 128; // 4个字节
        byte b = (byte)i; // 2个字节
        System.out.println(b); // -128！！！
    }
}
```

* ##### Why ?! -128是什么鬼?本着"向上找原因"的原则 , 我们先来看下强制类型转换的原理

#### 原理 :

#### ![](/assets/强制类型转换的原理.png)

```java
如上图所示:
i变量中存储了128(见i内存图)
b变量占1个字节的内存空间,即8位(bit)
强制类型转换就相当于把i的低8位直接拿到了b变量中(见b内存图)
问题继续:
```

* ##### 根据上图可见 , i 的有效位都拿到了 b 中 , 那为什么 i = 128 而 b = -128呢?!

```java
对于这个问题的解释,我们首先需要基于计算机组成原理中对于负数在计算机中存储方式的结论
- 在计算机中,若一个二进制数据的最高位是1,那么该数据肯定是一个负数;
- 若一个二进制数据的最高位是0,那么该数据肯定是一个正数;
- 且负数在计算机中存储的是其原数据的补码;
```

* ##### 首先 , 我们先来验证下上述结论

```java
/*
    sun提供给我们一个用于查看一个数据的二进制形式的功能 - Integer.toBinaryString(data)
    如下,没有原因,我们只需要验证,因为计算机存储负数的情况就是这样设计的 ...
*/
class Demo02 {
    public static void main(String[] args){
        System.out.println(Integer.toBinaryString(-7)); // 11111001
        System.out.println(Integer.toBinaryString(-1)); // 11111111
    }
}
```

* ##### 难么接下来的问题就是 -7的这个二进制数据到底是怎么来的？结论说它是原数据的补码 , 那么我又该如何根据它获取到原数据？

![](/assets/负数的存储过程.png)

```java
如上图所示,我们先给出负数在计算机中的存储过程(即补码的计算过程),来探讨下-7在计算机中存储的11111001到底是怎么来的:
- 1、00000111(原码)
- 2、11111000(按位取反:0->1、1->0)
- 3、11111001(补码:正是我们上面所看到的的结果！)
那么我们逆着负数的存储过程,很容易就能通过补码得到其真实数据
- 1、11111000(-1->反码)
- 2、00000111(取反->原码)
- 3、-7(添负号->真实数据)
```

* ##### 如此一来 , -128我们也就可以来解释一把了

```java
首先,b中存储的10000000的最高位是1,所以其一定是一个负数;
其次,负数在计算机中以其补码的形式存储,故根据上述逆负数的存储过程:
- 1、01111111(-1->反码)
- 2、10000000(取反->原码)
- 3、-128(添负号->真实数据)
```

#### 注意 :

* ##### 凡是byte、short 、 char数据类型的数据在运算的时候都会先自动转换成int类型的数据再运算

```java
class Demo02 {
	public static void main(String[] args){
		byte b1 = 1;
		byte b2 = 2;
		byte b3 = (byte)(b1+b2);
		System.out.println(b3);
	}
}
```



