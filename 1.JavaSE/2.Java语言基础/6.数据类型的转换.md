## 自动类型转换

```java
class Demo02 {
    public static void main(String[] args){
        byte b = 11; // 声明byte类型的b变量,并将11存储到b变量中
        short s = b; // 声明short类型的s变量,并将b变量中存储的值存储到s变量中
        int i = s; // 声明int类型的i变量,并将s变量中存储的值存储到i变量中
        long l = i; // 声明long类型的l变量,并将i变量中存储的值存储到l变量中
        System.out.println(l);
    }
}
```

* #### 如上所示\(小数据类型-&gt;大数据类型\)

```java
byte类型的b变量,占1个字节的内存空间,好比一两碗;
short类型的s变量,占2个字节的内存空间,好比二两碗,以此类推...
一两碗能盛得了的饭,二两碗能盛,以此类推...
故小数据类型到大数据类型的转换是自动完成的,不需要任何的其他操作;
```

## 强制类型转换

#### 格式 : \(大数据类型-&gt;小数据类型\)

```java
小数据类型 变量名 = (小数据类型)大数据类型[变量名];
```

* ##### 示例 :

```java
/*
    四两碗盛得饭可能比二两碗盛得饭多,即可能会溢出数据...
*/
class Demo02 {
    public static void main(String[] args){
        int i = 10; // 4个字节
        byte b = (byte)i; // 2个字节
        System.out.println(b);
    }
}
```

#### 疑问 :

* ##### 上述之所以能够强转 , 是因为 10 并没有超出 b 变量所能表示数据的范围 ; 那么假如说 i = 128 呢? b 的值是不是我们想象中溢出后的127呢?

```java
/*
	四两碗盛得饭可能比二两碗盛得饭多,即可能会溢出数据...
*/
class Demo02 {
	public static void main(String[] args){
		int i = 128; // 4个字节
		byte b = (byte)i; // 2个字节
		System.out.println(b); // -128！！！
	}
}
```



